// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "./LockedCacheGoldAPIConsumer.sol";

interface KeeperCompatibleInterface {
    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);
    function performUpkeep(bytes calldata performData) external;
}

contract CacheGoldLockedDataCronKeeper is KeeperCompatibleInterface {
    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    address private immutable _cacheGoldLockedOracle;
    uint256 private _lockedGold;
    
    address public cacheGoldLockedDataAPIConsumer;

    constructor(address cacheGoldLockedOracle, address _cacheGoldLockedDataAPIConsumer) {
      _cacheGoldLockedOracle = cacheGoldLockedOracle;
      cacheGoldLockedDataAPIConsumer = _cacheGoldLockedDataAPIConsumer;
    }

    ///TODO: check the cache oracle first if the locked oracle value in cache contract differs from the locked gold value in chainlink contract
    function checkUpkeep(bytes calldata checkData) external  override returns  (bool upkeepNeeded, bytes memory performData)   {
        
        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).call(abi.encodeWithSignature("lockedGold()"));
        require(success, "Unable to fetch locked gold oracle data");
        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));
        if(lockedGoldInCacheOracle != _lockedGold){
            return(true, abi.encodeWithSignature("requestedLockedData(string)", "grams_locked")); 
        }
        else{
            return (false, checkData);
        }
    }

    function performUpkeep(bytes calldata performData) external override {
        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).call(abi.encodeWithSignature("lockedGold()"));
        require(success, "Unable to fetch locked gold oracle data");
        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));
        _lockedGold = lockedGoldInCacheOracle;
    
        // We don't use the performData in this example
        // performData is generated by the Keeper's call to your `checkUpkeep` function
        (bool successPerformData,) = address(cacheGoldLockedDataAPIConsumer).call(performData);
        require(successPerformData, "Unable to perform upkeep");
    }

    function cacheGoldContractAddress() external view returns(address) {
        return _cacheGoldLockedOracle;
    }
}